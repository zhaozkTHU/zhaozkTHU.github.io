[{"title":"string分割为单词","url":"/uncategorized/string%E5%88%86%E5%89%B2%E4%B8%BA%E5%8D%95%E8%AF%8D/","content":"#include&lt;sstring&gt;需要头文件\n#include&lt;iostream&gt;#include&lt;sstring&gt;using namespace std;int main() {    string sentence;    getline(cin, sentence);    istringstream str(sentence);    vector&lt;string&gt; words;    string word;    while(str &gt;&gt; word)        words.push_back(word);    for(auto a : words) cout &lt;&lt; a &lt;&lt; endl;}\n","tags":["c++"]},{"title":"字符串处理与正则表达式","url":"/uncategorized/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"正则表达式\n正则表达式：由字母和符号组成的特殊文本，搜索文本时定义的一种规则\n^[a-z0-9_]{3,15}$\n\n三种模式\n\n匹配：判断整个字符串是否满足条件\n^[a-zo-9_]{3,15}$\n能与john匹配，不能与JOHN匹配\n\n搜索：符合正则表达式的子串\n在”q123e456w”找出所有数字串 [0-9]+\n搜索结果 123，456\n\n替换：按规则替换字符串的子串\n给定”q123e456w”将所有数字串替换为(number)\n替换结果q(123)e(456)w\n\n\n\n字符代表其本身\n如：使用the进行搜索，可以找到句中所有的”the”\n​\tThe car parked in the garage.\n\n匹配的单个字符在某个范围中\n\n[a-z] 匹配所有单个小写字母\n[0-9] 匹配所有单个数字\n\n\n连用\n\n[a-z] [0-9]  匹配所有字母+数字的组合，比如a1，b9\n[Tt]he:  The car parked in the garage.\n\n\n特殊字符\n\n\\d  等价[0-9],匹配所有单个数字\n\n\\w 匹配字母、数字、下划线。等价 [a-zA-Z0-9_]\n\n. 匹配除换行以外任意字符\n​\t.ar:  The car parked in the garage.\n\n\\. 可表示匹配句号\n​\tge\\. The car parked in the garage.\n\n\n\n重复模式\n\nx{n,m} 代表前面内容重复n~m次\n\na{4} 匹配aaaa\na{2,4} 匹配aa,aaa,aaaa\na{2,} 匹配长度大于等于2的a\n\n\n特殊字符\n+：前一个字符至少连续出现1次及以上\n​\t\ta\\w+： The car parked in the garage.\n\n\n\n辅助工具：http://tool.chinaz.com/regex/\n\n\n正则表达式库&lt; regex &gt;\n#include&lt;regex&gt;\n\n创建一个正则表达式对象\n\nregex re(\"^[1-9][0-9]{10}\")\n\n注意：c++的字符串中”\"也是转义字符\n如果需要创建正则表达式”\\d+”，应该写成regex re(\"\\\\d+\")\n\n\n\n\n原生字符串\n取消转义，保留字面值\n\nR\"(str)\" 表示str的字面值\n\n\\\\d+ = R\"(\\d+)\" = \\d+\n\n原生字符串可以换行，例如\nstring str = R\"(Helloworld)\"; //str = \"hello\\nworld\"\n\nregex库的使用\n匹配\nregex_match(s, re)：询问字符串s是否能完全匹配正则表达式re\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;regex&gt;using namespace std;int main() {\tstring s(\"subject\");\tregex e(\"sub.*\");\tsmatch sm;\tif(regex_match(s,e))\t\tcout &lt;&lt; \"matched\" &lt;&lt; endl;\treturn 0;}   //输出matched\n\n使用()进行标识，每个标识的内容被称为分组\n\n正则表达式匹配后，每个分组的内容将被捕获\n用于提取关键信息，例如version(\\d+)即可捕获版本号\n\n\n捕获和分组\n\nregex_match(s, result, re)：寻味字符串s是否能完全匹配正则表达式re，并将捕获结果储存到result\nresult需要是smatch类型的对象\n\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;regex&gt;using namespace std;int main () {\tstring s(\"version10\");\tregex e(R\"(version(\\d+))\"); smatch sm;\tif(regex_match(s,sm,e)) {\t\tcout &lt;&lt; sm.size() &lt;&lt; \" matches\\n\";\t\tcout &lt;&lt; \"the matches were:\" &lt;&lt; endl;\t\tfor (unsigned i=0; i&lt;sm.size(); ++i) {\t\t\tcout &lt;&lt; sm[i] &lt;&lt; endl;\t\t}\t}\treturn 0;}/*2 matchesthe matches wereversion1010*/\n\n分组会按顺序标号\n\n0号永远是匹配的字符串本身\n(a)(pple)：0号为apple，1号为a，2号为pple\n\n\n搜索\n\nregex_search(s, result, re)：搜索字符串s中能够匹配正则表达式re的第一个子串，并存储至result\nresult为smatch对象\n分组同样会被捕获\n\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;regex&gt;using namespace std;int main() {\tstring s(\"this subject has a submarine\");\tregex e(R\"((sub)([\\S]*))\");\tsmatch sm;\t//每次搜索时当仅保存第一个匹配到的子串\twhile(regex_search(s,sm,e)){\t\tfor (unsigned i=0; i&lt;sm.size(); ++i)\t\t\tcout &lt;&lt; \"[\" &lt;&lt; sm[i] &lt;&lt; \"] \";\t\tcout &lt;&lt; endl;\t\ts = sm.suffix().str();\t}\treturn 0;}//[subject] [sub] [ject]//[submarine] [sub] [marine]\n\n替换\n\nregex_replace(s, re, s1)：替换字符串s中所有匹配正则表达式re的子串，并替换成s1\ns1可以是一个普通文本\n\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;regex&gt;using namespace std;int main() {\tstring s(\"this subject has a submarine\");\tregex e(R\"(sub[\\S]*)\");\t//regex_replace返回值即为替换后的字符串 \tcout &lt;&lt; regex_replace(s,e,\"SUB\") &lt;&lt; \"\\n\";\treturn 0;}//this SUB has a SUB\n\ns1也可以使用一些特殊符号，代表捕获的分组\n$&amp; 代表re匹配的子串\n$1 $2代表re匹配的第1/2个分组\n\n\n\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;regex&gt;using namespace std;int main() {\tstring s(\"this subject has a submarine\");\tregex e(R\"((sub)([\\S]*))\");\t//regex_replace返回值即为替换后的字符串 \tcout &lt;&lt; regex_replace(s,e,\"SUBJECT\") &lt;&lt; endl;\t//$&amp;表示所有匹配成功的部分，[$&amp;]表示将其用[]括起来\tcout &lt;&lt; regex_replace(s,e,\"[$&amp;]\") &lt;&lt; endl;\t//$i输出e中第i个括号匹配到的值\tcout &lt;&lt; regex_replace(s,e,\"$1\") &lt;&lt; endl;\tcout &lt;&lt; regex_replace(s,e,\"$2\") &lt;&lt; endl;\tcout &lt;&lt; regex_replace(s,e,\"$1 and [$2]\") &lt;&lt; endl;\treturn 0;}//this SUBJECT has a SUBJECT//this [subject] has a [submarine]//this sub has a sub//this ject has a marine//this sub and [ject] has a sub and [marine]\n\n"},{"title":"群论","url":"/uncategorized/%E7%BE%A4%E8%AE%BA/","content":"1 半群定义1.1设S是非空集合，是S上的一个二元运算，如果满足结合律，则代数系统称为半群\n换句话说，如果对于任意的,若成立，则称为半群\n定义1.2若半群中有单位元存在，则称是一个==含幺半群==或简称==幺群==\n幺群有时会用三元组表示\n定义1.3设是一个幺群，若适合交换律，则称M是==交换幺群==\n定义1.4是一个幺群，若存在一个元素,使得对任意，a都可以写成g的方幂形式，即(m是非负整数),则称是一个==循环幺群==，并称g是M的一个==生成元==\n定义1.5设是一个半群，，在运算的作用下如果T是封闭的，则称是的==子半群==\n2 群的基本性质定义2.1设G是非空集合，是G上的二元运算，若代数系统满足\n\n适合结合律\n存在单位元e\nG中的元素均为可逆元\n\n则称代数系统是一个==群==，或记为\n","tags":["离散数学"]},{"title":"函数与类模板特化","url":"/uncategorized/%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96/","content":"函数模板特化\n有时，有些类型并不合适，则需要对模板在某种情况下的具体类型进行特殊处理，这称为模板特化\n\n对于如下模板进行特化的两种方法\ntemplate&lt;typename T&gt; T sum(T a, T b)\n\n在函数名后用&lt;&gt;括起具体类型\ntemplate&lt;&gt; char* sum&lt;char*&gt;(char* a, char* b)\n\n由编译器推导出具体类型，函数名为普通形式\ntemplate&lt;&gt; char* sum(char* a, char* b)\n\n\n\n注意：对于函数模板，如果由多个模板参数，则特化时必须提供所有参数的特例类型，不能部分特化\n但可以使用重载来替代部分特化\n#include&lt;iostream&gt;using namespace std;template&lt;class T, class A&gt;T sum(const A&amp; val1, const A&amp; val2) {    cout &lt;&lt; \"using template\" &lt;&lt; endl;    return T(val1 + val2);}template&lt;class A&gt;int sum(const A&amp; val1, const A&amp; val2) {    cout &lt;&lt; \"overload\" &lt;&lt; endl;    return int(val1 + val2);}int main() {    float y = sum&lt;float, float&gt;(1.4, 2.4);    cout &lt;&lt; y &lt;&lt; endl;    int x = sum(1, 2);    cout &lt;&lt; x &lt;&lt; endl;    return 0;}//using template//3.8//overload//3\n\n函数模板重载解析顺序：\n类型匹配的普通函数-&gt;基础函数模板-&gt;全特化函数模板\n\n如果由普通函数且类型匹配，则直接选中，重载解析结束\n如果没有类型匹配的普通函数，则选择最合适的基础模板\n如果选中的基础模板有全特化版本且类型匹配，则选择全特化版本，否则使用基础模板\n\n\n\n类模板特化\n对于类模板，也可以进行特化\n\n对于以下模板\ntemplate&lt;typename T1, typenameT2&gt; class A {...};\n与函数模板类似，可以进行全部特化：\ntemplate&lt;&gt; class A&lt;int, int&gt; {...};\n\n对于类模板，还允许部分特化，即只部分限制模板的通用性，如通用模板为：\ntemplate&lt;typename T1, typename T2&gt; class A {...};\n部分特化：第二个类型指定为int\ntemplate&lt;typename T1&gt; class A&lt;T1, int&gt; {...};\n\n\n模板特化总结\n类模板可以部分特化或者全部特化，编译器会根据调用时的类型参数自动选择合适的模板类\n函数模板只能全部特化，但可以通过重载代替部分特化的实现。编译器在编译阶段决定使用特化函数或者标准模板函数\n函数模板的全特化啊版本的匹配优先级可能低于重载的非特化基础函数模板，因此最好不要使用全特化函数模板而直接使用重载函数\n\n"},{"title":"迭代器","url":"/uncategorized/%E8%BF%AD%E4%BB%A3%E5%99%A8/","content":"自定义迭代器:\n\niterator begin()\niterator end()  //begin()与end()在迭代器外、将要迭代的类内定义\niterator operator++() //前缀运算符\niterator operator*() 解引用\nbool operator!=(iterator)\nbool operator==(iterator)\n\n#include \"dataloader.hpp\"#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;string matrix_unicode(vector&lt;vector&lt;int&gt;&gt;&amp; mat){    // this is a function to check print batch data for answer checking    string unicode = \"[\";    for (auto row : mat){        unicode += \"[\";        for (auto elem : row){            unicode += std::to_string(elem)+\",\";        }        unicode.erase(unicode.end()-1);        unicode += \"],\";    }    unicode.erase(unicode.end()-1);    unicode+=\"]\";    return unicode;}int main(){    int N, NUM_EPOCH, BATCH_SIZE;    cin &gt;&gt; N;    Vocabulary V;    DataLoader D;    cin.get();    for (int i=0; i&lt;N; i++){        string sentence;        getline(cin, sentence);        D.addData(V.insertSentReturnIds(sentence));    }    cin &gt;&gt; NUM_EPOCH;    for (int i=0; i&lt;NUM_EPOCH; i++){        cin &gt;&gt; BATCH_SIZE;        vector&lt;int&gt; random_order;        for (int j=0;j&lt;N;j++){            int tmp;            cin &gt;&gt; tmp;            random_order.push_back(tmp);        }        D.setOrder(random_order);        D.setBatchSize(BATCH_SIZE);        for (auto batch : D){ //此处会自动调用D的迭代器            string str = matrix_unicode(batch);            cout&lt;&lt; str &lt;&lt;endl;        }    }    return 0;}\n\n#include &lt;map&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include&lt;sstream&gt;using namespace std;class Vocabulary{private:    // Choose a proper container from STL.    static int id;    map&lt;string, int&gt; voc;public:    vector&lt;int&gt; insertSentReturnIds(string sentence){        vector&lt;int&gt; returnvalue;        istringstream str(sentence);        vector&lt;string&gt; words;        string word;        while(str &gt;&gt; word) {            if(voc.count(word) == 0) {                voc[word] = id;                id++;            }            returnvalue.push_back(voc[word]);        }        return returnvalue;    }};int Vocabulary::id = 1;class DataLoader{private:    vector&lt;int&gt; _rand_order;    int batch_size=0;    vector&lt;vector&lt;int&gt;&gt; sentences;    vector&lt;vector&lt;int&gt;&gt; sorted;    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; _result; //batch_size赋值时进行操作，迭代器对此进行迭代public:    void setBatchSize(int N) {        this-&gt;batch_size = N;         int a;        if (sentences.size() % batch_size == 0) a = sentences.size() / batch_size;        else a = (sentences.size() - sentences.size() % batch_size) / batch_size + 1;        _result = vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;(a);        for (int i = 0; i &lt; sentences.size(); i++) {            _result[i / batch_size].push_back(sorted[i]);        }        for(int i = 0; i &lt; _result.size(); i++) {            int maxn = 0;            for(int j = 0; j &lt; _result[i].size(); j++) {                if(_result[i][j].size() &gt; maxn) maxn = _result[i][j].size();            }            for(int j = 0; j &lt; _result[i].size(); j++) {                int a = _result[i][j].size();                if(_result[i][j].size() &lt; maxn) {                    for(int k = 0; k &lt; maxn - a; k++)                        _result[i][j].push_back(0);                }            }        }    }    void setOrder(vector&lt;int&gt;&amp; x) {        _rand_order = x;        sorted.clear();        _result.clear();        for(int i = 0; i &lt; sentences.size(); i++) {            sorted.push_back(sentences[_rand_order[i]]);        }    }    void addData(vector&lt;int&gt; sent_encoding) {        sentences.push_back(sent_encoding);    }    struct Iterator    {        bool operator!= (Iterator other) const {return this-&gt;begin != other.begin;}        bool operator== (Iterator other) const {return this-&gt;begin == other.begin;}        Iterator(vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;::iterator b) : begin(b) {}        Iterator operator++() {            return Iterator(begin++);        }        vector&lt;vector&lt;int&gt;&gt; operator* () {            return *begin;        }    private:        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;::iterator begin;    };    Iterator begin() {        return Iterator(_result.begin());    }    Iterator end() {        return Iterator(_result.end());    }};\n\n","tags":["c++"]}]