[{"title":"string分割为单词","url":"/uncategorized/string%E5%88%86%E5%89%B2%E4%B8%BA%E5%8D%95%E8%AF%8D/","content":"#include&lt;sstring&gt;需要头文件\n#include&lt;iostream&gt;#include&lt;sstring&gt;using namespace std;int main() {    string sentence;    getline(cin, sentence);    istringstream str(sentence);    vector&lt;string&gt; words;    string word;    while(str &gt;&gt; word)        words.push_back(word);    for(auto a : words) cout &lt;&lt; a &lt;&lt; endl;}\n","tags":["c++"]},{"title":"迭代器","url":"/uncategorized/%E8%BF%AD%E4%BB%A3%E5%99%A8/","content":"自定义迭代器:\n\niterator begin()\niterator end()  //begin()与end()在迭代器外、将要迭代的类内定义\niterator operator++() //前缀运算符\niterator operator*() 解引用\nbool operator!=(iterator)\nbool operator==(iterator)\n\n#include \"dataloader.hpp\"#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;string matrix_unicode(vector&lt;vector&lt;int&gt;&gt;&amp; mat){    // this is a function to check print batch data for answer checking    string unicode = \"[\";    for (auto row : mat){        unicode += \"[\";        for (auto elem : row){            unicode += std::to_string(elem)+\",\";        }        unicode.erase(unicode.end()-1);        unicode += \"],\";    }    unicode.erase(unicode.end()-1);    unicode+=\"]\";    return unicode;}int main(){    int N, NUM_EPOCH, BATCH_SIZE;    cin &gt;&gt; N;    Vocabulary V;    DataLoader D;    cin.get();    for (int i=0; i&lt;N; i++){        string sentence;        getline(cin, sentence);        D.addData(V.insertSentReturnIds(sentence));    }    cin &gt;&gt; NUM_EPOCH;    for (int i=0; i&lt;NUM_EPOCH; i++){        cin &gt;&gt; BATCH_SIZE;        vector&lt;int&gt; random_order;        for (int j=0;j&lt;N;j++){            int tmp;            cin &gt;&gt; tmp;            random_order.push_back(tmp);        }        D.setOrder(random_order);        D.setBatchSize(BATCH_SIZE);        for (auto batch : D){ //此处会自动调用D的迭代器            string str = matrix_unicode(batch);            cout&lt;&lt; str &lt;&lt;endl;        }    }    return 0;}\n\n#include &lt;map&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include&lt;sstream&gt;using namespace std;class Vocabulary{private:    // Choose a proper container from STL.    static int id;    map&lt;string, int&gt; voc;public:    vector&lt;int&gt; insertSentReturnIds(string sentence){        vector&lt;int&gt; returnvalue;        istringstream str(sentence);        vector&lt;string&gt; words;        string word;        while(str &gt;&gt; word) {            if(voc.count(word) == 0) {                voc[word] = id;                id++;            }            returnvalue.push_back(voc[word]);        }        return returnvalue;    }};int Vocabulary::id = 1;class DataLoader{private:    vector&lt;int&gt; _rand_order;    int batch_size=0;    vector&lt;vector&lt;int&gt;&gt; sentences;    vector&lt;vector&lt;int&gt;&gt; sorted;    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; _result; //batch_size赋值时进行操作，迭代器对此进行迭代public:    void setBatchSize(int N) {        this-&gt;batch_size = N;         int a;        if (sentences.size() % batch_size == 0) a = sentences.size() / batch_size;        else a = (sentences.size() - sentences.size() % batch_size) / batch_size + 1;        _result = vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;(a);        for (int i = 0; i &lt; sentences.size(); i++) {            _result[i / batch_size].push_back(sorted[i]);        }        for(int i = 0; i &lt; _result.size(); i++) {            int maxn = 0;            for(int j = 0; j &lt; _result[i].size(); j++) {                if(_result[i][j].size() &gt; maxn) maxn = _result[i][j].size();            }            for(int j = 0; j &lt; _result[i].size(); j++) {                int a = _result[i][j].size();                if(_result[i][j].size() &lt; maxn) {                    for(int k = 0; k &lt; maxn - a; k++)                        _result[i][j].push_back(0);                }            }        }    }    void setOrder(vector&lt;int&gt;&amp; x) {        _rand_order = x;        sorted.clear();        _result.clear();        for(int i = 0; i &lt; sentences.size(); i++) {            sorted.push_back(sentences[_rand_order[i]]);        }    }    void addData(vector&lt;int&gt; sent_encoding) {        sentences.push_back(sent_encoding);    }    struct Iterator    {        bool operator!= (Iterator other) const {return this-&gt;begin != other.begin;}        bool operator== (Iterator other) const {return this-&gt;begin == other.begin;}        Iterator(vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;::iterator b) : begin(b) {}        Iterator operator++() {            return Iterator(begin++);        }        vector&lt;vector&lt;int&gt;&gt; operator* () {            return *begin;        }    private:        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;::iterator begin;    };    Iterator begin() {        return Iterator(_result.begin());    }    Iterator end() {        return Iterator(_result.end());    }};\n\n","tags":["c++"]},{"title":"群论","url":"/uncategorized/%E7%BE%A4%E8%AE%BA/","content":"1 半群定义1.1设S是非空集合，是S上的一个二元运算，如果满足结合律，则代数系统称为半群\n换句话说，如果对于任意的,若成立，则称为半群\n定义1.2若半群中有单位元存在，则称是一个==含幺半群==或简称==幺群==\n幺群有时会用三元组表示\n定义1.3设是一个幺群，若适合交换律，则称M是==交换幺群==\n定义1.4是一个幺群，若存在一个元素,使得对任意，a都可以写成g的方幂形式，即(m是非负整数),则称是一个==循环幺群==，并称g是M的一个==生成元==\n定义1.5设是一个半群，，在运算的作用下如果T是封闭的，则称是的==子半群==\n2 群的基本性质定义2.1设G是非空集合，是G上的二元运算，若代数系统满足\n\n适合结合律\n存在单位元e\nG中的元素均为可逆元\n\n则称代数系统是一个==群==，或记为\n","tags":["离散数学"]}]